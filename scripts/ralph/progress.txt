## Codebase Patterns

- **Font handling architecture**: Fonts are cached in `CachedFont` struct in interpreter.rs. Simple fonts use `FontMetrics` (widths array indexed by char_code - first_char). CID fonts use `CidFontMetrics` (HashMap<u32, f64> for sparse widths + default_width).
- **lopdf object resolution**: Always resolve indirect references via `resolve_object(doc, obj)` before accessing dictionaries or arrays.
- **Width function pattern**: The interpreter creates a width closure `get_width_fn(cached)` that dispatches to CID or simple metrics.
- **CMap types**: `CMap` maps char_code→Unicode string (for ToUnicode). `CidCMap` maps char_code→CID (for predefined CMaps).
- **Type0 font loading flow**: `is_type0_font()` → `get_descendant_font()` → `extract_cid_font_metrics()` → stores in `CachedFont.cid_metrics`.

# Ralph Progress Log
Started: 2026년  2월 28일 토요일 10시 21분 21초 KST
---

## 2026-02-28 - US-040
- Implemented CID font support: CID-to-GID mapping, predefined CMap parsing, /W and /DW width handling
- New file: `crates/pdfplumber-parse/src/cid_font.rs` — CidFontMetrics, CidToGidMap, CidSystemInfo, PredefinedCMapInfo, W array parsing, Type0 font detection
- Modified: `crates/pdfplumber-parse/src/cmap.rs` — Added CidCMap struct for begincidchar/begincidrange parsing, CMap name/WMode parsing
- Modified: `crates/pdfplumber-parse/src/interpreter.rs` — CachedFont now holds cid_metrics, is_cid_font, writing_mode; load_font_if_needed detects Type0 fonts; width lookup uses CID metrics when available
- Modified: `crates/pdfplumber-parse/src/lib.rs` — Exports new CID font types
- Dependencies added: none
- **Learnings for future iterations:**
  - /W array has two formats: `CID [w1 w2 ...]` (individual) and `CIDstart CIDend w` (range) — need to detect arrays vs integers
  - CIDToGIDMap is most commonly /Identity; explicit mapping is a raw byte stream of big-endian u16 pairs
  - Predefined CMap names follow patterns: Adobe-Japan1-*, UniJIS-UTF16-H, 90ms-RKSJ-H, etc.
  - clippy requires `#[allow(clippy::too_many_arguments)]` for constructors with 8+ params
  - Use `if let Ok(v) = x.parse()` not `if let Some(v) = x.parse().ok()` (clippy::match_result_ok)
---
