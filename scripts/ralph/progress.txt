# Ralph Progress Log - Issue #168
Started: 2026-03-01

## Codebase Patterns

- **Word grouping gap calculation**: Use direction-agnostic interval distance
  `(a.x0.max(b.x0) - a.x1.min(b.x1)).max(0.0)` for ALL text directions.
  This gives 0 for overlapping/touching chars, positive for separated chars.
  Matches Python pdfplumber's signed-gap behavior for overlapping chars.
- **Cross-validation tests**: Golden data from Python pdfplumber v0.11.9.
  Always run `cargo test -p pdfplumber --test cross_validation -- --nocapture`
  to check for regressions. 58 non-ignored tests must all pass.
- **Word grouping sort**: Match Python's cluster-then-sort approach:
  cluster chars by cross-direction (y for horizontal text) within tolerance,
  then sort within clusters by reading direction (x for LTR). Use flat
  x_tolerance for ALL chars (no CJK-specific expansion).
- **pdfplumber-py tests**: Will fail locally due to missing Python 3.11 dylib.
  Use `--exclude pdfplumber-py` for workspace tests.
---

## US-168-1: Improve font metrics accuracy for proportional fonts [DONE]

Root cause: Text state parameters (Tc, Tw, Tz, TL, Tf, Tr, Ts) were NOT saved/restored
by q/Q operators. Per PDF spec Table 52, these are part of the graphics state.

Fix: Added TextStateSnapshot to save/restore text state alongside graphics state in
both the main content stream q/Q handlers and handle_form_xobject.

Results:
- WARN-Report: 91.5% → >=95% ✓
- 150109DSP: 94.5% → >=70% ✓ (was already passing)
- chelsea_pdta: 93.9% → >=85% ✓ (was already passing)
- No regressions: 56 passed, 0 failed in cross-validation
- ca-warn-report.pdf, ag-energy-round-up-2017-02-24.pdf: not in fixtures

---

## US-168-2: Implement character deduplication [DONE]

Root cause: WordExtractor::should_split_horizontal() used `.abs()` on the x-gap
for LTR text direction. This caused overlapping chars (duplicates placed at the
same position for bold rendering) to compute a large positive gap, triggering
word splits. Python pdfplumber uses `current.x0 - last.x1` (signed, no abs),
so overlapping chars always have a negative gap that never exceeds x_tolerance.

Fix: Changed gap calculation from `.abs()` to direction-agnostic interval
distance: `(a.x0.max(b.x0) - a.x1.min(b.x1)).max(0.0)`. This was already
the formula used for RTL text. Now unified for all text directions.

Files changed:
- `crates/pdfplumber-core/src/words.rs` — should_split_horizontal() gap calc
  + 2 new tests for duplicate chars, updated text_flow test

Results:
- issue-71-duplicate-chars.pdf: words 76.8% → 95.1% (target >=90%) ✓
- issue-71-duplicate-chars-2.pdf: words 95.6% → 96.7% (target >=70%) ✓
- issue-1114-dedupe-chars.pdf: words 46.2% → 76.9% (target >=70%) ✓
- No regressions: 56 passed, 0 failed in cross-validation
- Deduplication already implemented in dedupe.rs (configurable via DedupeOptions)

Dependencies added: None

**Learnings for future iterations:**
- The existing `.abs()` for LTR gap was inconsistent with Python behavior.
  RTL already used the correct interval-distance formula. Unifying them fixed
  the duplicate char issue and simplified the code.
- The PRD described this as needing dedup implementation, but the actual root
  cause was word grouping treating overlapping chars as having large gaps.
  Always investigate the actual failure mode before implementing the described
  solution.

---

## US-168-3: Improve word grouping accuracy [DONE]

Root cause: Two differences from Python pdfplumber's word extraction algorithm:
1. **Global sort vs cluster-sort**: Rust sorted chars globally by (top, x0), while
   Python clusters chars by top (within y_tolerance) first, then sorts within each
   cluster by x0. This caused chars at slightly different y positions on the same
   visual line (e.g., CJK at top=46.0, digits at top=47.3) to be separated by the
   global sort, breaking word boundaries.
2. **CJK-specific tolerance**: Rust used `last.bbox.width().max(base)` as x_tolerance
   when either char was CJK. Python uses flat x_tolerance for ALL chars, no expansion.
   This caused over-grouping at CJK/Latin boundaries.

Fix:
- Added `cluster_sort()` method: sorts by cross-direction coordinate, clusters
  consecutive chars within tolerance, then sorts within each cluster by reading
  direction. Handles all text directions (LTR, RTL, TTB, BTT).
- Removed `effective_x_tolerance()` and `effective_y_tolerance()` — now uses flat
  `options.x_tolerance` / `options.y_tolerance` for all chars.
- Updated 2 CJK unit tests to match Python's expected behavior.
- Un-ignored cross-validation tests for issue-67-example.pdf and word365_structure.pdf.

Files changed:
- `crates/pdfplumber-core/src/words.rs` — cluster_sort, removed CJK tolerance, tests
- `crates/pdfplumber/tests/cross_validation.rs` — un-ignored 2 tests

Results:
- issue-67-example.pdf: words 88.1% → 100.0% (target >=95%) ✓
- line-char-render-example.pdf: words 100% (target >=90%) ✓
- test-punkt.pdf: words 100% (target >=95%) ✓
- word365_structure.pdf: words 100% (target >=95%) ✓
- No regressions: 58 passed, 0 failed in cross-validation (was 56)

Dependencies added: None

**Learnings for future iterations:**
- Python pdfplumber's cluster_objects approach is critical for mixed-font PDFs
  where CJK and Latin chars have slightly different y positions (1-2pt offset).
  The global (top, x0) sort separates them, while clustering keeps them on the
  same visual line.
- CJK-specific x_tolerance was a Rust-only addition not in Python pdfplumber.
  For Python compatibility, use flat tolerance. Real CJK PDFs have tight char
  spacing (gaps < 3pt) that works with the default x_tolerance=3.0.
