{
  "project": "pdfplumber-rs",
  "branchName": "ralph/phase3-table-detection",
  "description": "Phase 3: Table Detection - Lattice, Stream, and Explicit strategies for table extraction",
  "userStories": [
    {
      "id": "US-029",
      "title": "TableSettings and TableFinder foundation",
      "description": "Define the TableSettings configuration and TableFinder struct that orchestrates the table detection pipeline.",
      "acceptanceCriteria": [
        "TableSettings struct: strategy (Lattice/LatticeStrict/Stream/Explicit), snap_tolerance, snap_x_tolerance, snap_y_tolerance, join_tolerance, join_x_tolerance, join_y_tolerance, edge_min_length, min_words_vertical, min_words_horizontal, text_tolerance, text_x_tolerance, text_y_tolerance, intersection_tolerance, intersection_x_tolerance, intersection_y_tolerance",
        "Default values matching pdfplumber defaults",
        "Strategy enum: Lattice, LatticeStrict, Stream, Explicit",
        "TableFinder struct that takes page data + settings and runs the detection pipeline",
        "Table struct: bbox, cells (Vec<Cell>), rows, columns",
        "Cell struct: bbox, text (Option<String>)",
        "Unit tests: settings construction, default values, strategy selection",
        "cargo test --workspace passes",
        "cargo clippy --workspace -- -D warnings passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Place in pdfplumber-core. This is the configuration layer for table detection."
    },
    {
      "id": "US-030",
      "title": "Edge processing - snap_edges() for parallel edge alignment",
      "description": "Implement snap_edges() that aligns nearby parallel edges to reduce noise from slight coordinate variations in PDFs.",
      "acceptanceCriteria": [
        "snap_edges() groups edges by orientation (horizontal/vertical)",
        "For each group, cluster edges within snap_tolerance along the perpendicular axis",
        "Replace clustered edges' perpendicular coordinates with the cluster mean/median",
        "Separate snap_x_tolerance and snap_y_tolerance for fine-grained control",
        "Does not merge edges, only aligns their positions",
        "Unit tests: snap nearby horizontal lines, snap nearby vertical lines, edges far apart remain unchanged, tolerance configuration",
        "cargo test --workspace passes",
        "cargo clippy --workspace -- -D warnings passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-031",
      "title": "Edge processing - join_edge_group() for segment merging",
      "description": "Implement join_edge_group() that merges overlapping or adjacent collinear edge segments into single edges.",
      "acceptanceCriteria": [
        "join_edge_group() takes edges on the same line and merges overlapping/adjacent segments",
        "Two edges merge if they are collinear and their gap is within join_tolerance",
        "Merged edge spans from min start to max end of constituent edges",
        "Separate join_x_tolerance and join_y_tolerance",
        "Handle multiple segments merging into one (chain merge)",
        "Unit tests: two overlapping edges merge, adjacent edges within tolerance merge, distant edges don't merge, chain of 3 segments",
        "cargo test --workspace passes",
        "cargo clippy --workspace -- -D warnings passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-032",
      "title": "Intersection detection - edges_to_intersections()",
      "description": "Implement edges_to_intersections() that finds all intersection points between horizontal and vertical edges.",
      "acceptanceCriteria": [
        "Find intersections between horizontal and vertical edges",
        "An intersection exists when a horizontal edge's y is within tolerance of a vertical edge's span, and vice versa",
        "Use intersection_tolerance for matching",
        "Return HashMap<(x, y), Intersection> with references to the intersecting edges",
        "Filter: only count intersections where edges actually overlap (not just their infinite extensions)",
        "Unit tests: simple cross intersection, T-intersection, L-intersection (corner), no intersection (parallel lines), tolerance-based intersection",
        "cargo test --workspace passes",
        "cargo clippy --workspace -- -D warnings passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-033",
      "title": "Cell construction - intersections_to_cells()",
      "description": "Implement intersections_to_cells() that constructs rectangular cells from a grid of intersection points.",
      "acceptanceCriteria": [
        "Group intersection points into a grid of rows (sorted by y) and columns (sorted by x)",
        "For each pair of adjacent row-lines and adjacent column-lines, check if all 4 corners have intersections",
        "If all 4 corners exist, create a Cell with the corresponding bbox",
        "Handle missing corners gracefully (skip incomplete cells)",
        "Return Vec<Cell> with proper bounding boxes",
        "Unit tests: simple 2x2 grid → 1 cell, 3x3 grid → 4 cells, grid with missing corner, irregular grid",
        "cargo test --workspace passes",
        "cargo clippy --workspace -- -D warnings passes"
      ],
      "priority": 5,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-034",
      "title": "Table grouping - cells_to_tables()",
      "description": "Implement cells_to_tables() that groups adjacent cells into distinct tables and organizes cells into rows and columns.",
      "acceptanceCriteria": [
        "Group cells that share edges into the same table",
        "Each table gets a bbox that is the union of all its cells",
        "Organize cells into rows (by y-coordinate) and columns (by x-coordinate)",
        "Table.rows: Vec<Vec<Cell>> ordered top-to-bottom, left-to-right",
        "Table.columns: Vec<Vec<Cell>> ordered left-to-right, top-to-bottom",
        "Handle multiple tables on the same page",
        "Unit tests: single table, two separate tables on same page, table with multiple rows and columns",
        "cargo test --workspace passes",
        "cargo clippy --workspace -- -D warnings passes"
      ],
      "priority": 6,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-035",
      "title": "Lattice strategy - complete line-based table detection",
      "description": "Wire the full Lattice pipeline: collect edges from lines + rect edges → snap → join → intersect → cells → tables.",
      "acceptanceCriteria": [
        "Lattice strategy: edges from Page::lines() + rect edges from Page::rects()",
        "LatticeStrict strategy: edges from Page::lines() only (no rect edges)",
        "Full pipeline: get_edges → snap_edges → join_edges → edges_to_intersections → intersections_to_cells → cells_to_tables",
        "Filter edges by min_length (edge_min_length setting)",
        "Integration test with a PDF containing a bordered table",
        "Unit tests: simple bordered table detection, strict mode excluding rects, edge filtering by length",
        "cargo test --workspace passes",
        "cargo clippy --workspace -- -D warnings passes"
      ],
      "priority": 7,
      "passes": false,
      "notes": "This is the primary table detection method."
    },
    {
      "id": "US-036",
      "title": "Cell text extraction - crop bbox + text within cell",
      "description": "Extract text content for each detected table cell by cropping characters within the cell's bounding box.",
      "acceptanceCriteria": [
        "For each Cell, find all Chars whose bbox center falls within the cell bbox",
        "Group and sort characters within cell using word grouping logic",
        "Cell.text = joined text of words within the cell",
        "Handle cells with no text (Cell.text = None)",
        "Handle text that slightly overflows cell boundaries (use center-point containment)",
        "Unit tests: cell with single word, cell with multiple lines, empty cell, text at cell boundary",
        "cargo test --workspace passes",
        "cargo clippy --workspace -- -D warnings passes"
      ],
      "priority": 8,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-037",
      "title": "Stream strategy - text-based synthetic edge table detection",
      "description": "Implement the Stream strategy that detects tables without visible borders by analyzing text alignment patterns.",
      "acceptanceCriteria": [
        "Collect words from the page using word extraction",
        "Detect vertical text alignment: group words sharing similar x0 or x1 coordinates → synthetic vertical edges",
        "Detect horizontal text alignment: group words sharing similar top or bottom coordinates → synthetic horizontal edges",
        "Filter by min_words_vertical and min_words_horizontal thresholds",
        "Feed synthetic edges into the same snap → join → intersect → cells pipeline",
        "Integration test with a PDF containing a borderless/form-style table",
        "Unit tests: aligned text produces synthetic edges, threshold filtering, full stream pipeline",
        "cargo test --workspace passes",
        "cargo clippy --workspace -- -D warnings passes"
      ],
      "priority": 9,
      "passes": false,
      "notes": "Stream strategy is harder to get right - focus on basic cases first."
    },
    {
      "id": "US-038",
      "title": "Explicit strategy - user-provided lines/coordinates",
      "description": "Implement the Explicit strategy where users provide their own horizontal and vertical line coordinates for table detection.",
      "acceptanceCriteria": [
        "ExplicitLines struct: horizontal_lines (Vec<f64> for y-coordinates), vertical_lines (Vec<f64> for x-coordinates)",
        "Convert user-provided coordinates to Edge objects",
        "Feed explicit edges into the intersection → cells → tables pipeline",
        "Allow mixing: explicit lines + detected lines",
        "TableSettings accepts optional explicit_lines field",
        "Unit tests: explicit grid detection, partial explicit (some lines user-provided, some detected)",
        "cargo test --workspace passes",
        "cargo clippy --workspace -- -D warnings passes"
      ],
      "priority": 10,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-039",
      "title": "Page table API - find_tables, extract_tables, extract_table",
      "description": "Wire table detection into the public Page API with the three table extraction methods matching pdfplumber.",
      "acceptanceCriteria": [
        "Page::find_tables(settings) -> Vec<Table> returns detected tables with cell objects",
        "Page::extract_tables(settings) -> Vec<Vec<Vec<Option<String>>>> returns tables as 2D text arrays",
        "Page::extract_table(settings) -> Option<Vec<Vec<Option<String>>>> returns the largest table",
        "All three methods use TableFinder internally with the specified strategy",
        "Integration test: extract table from a real PDF with a bordered table",
        "Integration test: extract table from a borderless table (Stream strategy)",
        "Unit tests: API wiring, empty page (no tables), multiple tables extraction",
        "cargo test --workspace passes",
        "cargo clippy --workspace -- -D warnings passes"
      ],
      "priority": 11,
      "passes": false,
      "notes": "Capstone story for Phase 3."
    }
  ]
}
